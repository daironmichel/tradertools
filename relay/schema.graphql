# source: http://localhost:5000/api/gql/
# timestamp: Thu Dec 26 2019 14:40:45 GMT-0500 (Eastern Standard Time)

"""An enumeration."""
enum AccountAccountMode {
  """CASH"""
  CASH

  """MARGIN"""
  MARGIN
}

"""An enumeration."""
enum AccountAccountStatus {
  """ACTIVE"""
  ACTIVE

  """CLOSED"""
  CLOSED
}

type AccountConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!
  edges: [AccountEdge!]!
}

type AccountEdge {
  cursor: String!
  node: AccountNode!
}

type AccountNode implements Node & DatabaseId {
  """The ID of the object."""
  id: ID!
  name: String!
  description: String!
  accountId: String!
  accountKey: String!
  accountType: String!
  institutionType: String!
  accountMode: AccountAccountMode!
  accountStatus: AccountAccountStatus!
  pdtStatus: String!
  cashBalance: Float!
  cashBuyingPower: Float!
  marginBuyingPower: Float!
  lastUpdated: DateTime!
  broker: BrokerNode!
  provider: ServiceProviderNode!
  databaseId: Int!
}

type AccountNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AccountNodeEdge]!
}

"""A Relay edge containing a `AccountNode` and its cursor."""
type AccountNodeEdge {
  """The item at the end of the edge"""
  node: AccountNode

  """A cursor for use in pagination"""
  cursor: String!
}

enum AuthorizeConnectionError {
  PROVIDER_NOT_FOUND
  INCOMPATIBLE_STATE
}

input AuthorizeConnectionInput {
  providerId: ID!
  oauthVerifier: String!
  clientMutationId: String
}

type AuthorizeConnectionPayload {
  serviceProvider: ServiceProviderNode
  error: AuthorizeConnectionError
  errorMessage: String
  clientMutationId: String
}

type BrokerNode implements Node & DatabaseId {
  """The ID of the object."""
  id: ID!
  name: String!
  slug: String!
  defaultProvider: ServiceProviderNode
  accounts(before: String, after: String, first: Int, last: Int): AccountConnection!
  serviceProviders(before: String, after: String, first: Int, last: Int): ServiceProviderConnection!
  databaseId: Int!
  serviceProvider(databaseId: ID, slug: String): ServiceProviderNode
}

enum BuyStockError {
  ACCOUNT_NOT_PROVIDED
}

input BuyStockInput {
  providerId: ID!
  strategyId: ID!
  symbol: String!
  accountId: ID
  clientMutationId: String
}

type BuyStockPayload {
  error: BuyStockError
  errorMessage: String
  clientMutationId: String
}

enum CancelOrderError {
  ACCOUNT_NOT_PROVIDED
}

input CancelOrderInput {
  providerId: ID!
  orderId: ID!
  accountId: ID
  clientMutationId: String
}

type CancelOrderPayload {
  error: CancelOrderError
  errorMessage: String
  clientMutationId: String
}

enum ConnectProviderError {
  PROVIDER_NOT_FOUND
}

input ConnectProviderInput {
  providerId: ID!
  clientMutationId: String
}

type ConnectProviderPayload {
  serviceProvider: ServiceProviderNode
  authorizeUrl: String
  callbackEnabled: Boolean
  error: ConnectProviderError
  errorMessage: String
  clientMutationId: String
}

interface DatabaseId {
  databaseId: Int!
}

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

"""The `Decimal` scalar type represents a python Decimal."""
scalar Decimal

type Mutation {
  connectProvider(input: ConnectProviderInput!): ConnectProviderPayload!
  authorizeConnection(input: AuthorizeConnectionInput!): AuthorizeConnectionPayload!
  syncAccounts(input: SyncAccountsInput!): SyncAccountsPayload!
  buyStock(input: BuyStockInput!): BuyStockPayload!
  sellStock(input: SellStockInput!): SellStockPayload!
  cancelOrder(input: CancelOrderInput!): CancelOrderPayload!
  saveSettings(input: SaveSettingsInput!): SaveSettingsPayload!
}

"""An object with an ID"""
interface Node {
  """The ID of the object."""
  id: ID!
}

type OrderType {
  orderId: ID!
  symbol: String!
  quantity: Int!
  limitPrice: Decimal!
  executionPrice: Decimal!
  status: String!
  action: String!
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type PositionType {
  symbol: String!
  pricePaid: Decimal!
  quantity: Int!
  totalGain: Decimal!
  totalGainPct: Decimal!
}

type ProviderSessionNode implements Node & DatabaseId {
  """The ID of the object."""
  id: ID!
  status: SessionStatus
  requestToken: String!
  requestTokenSecret: String!
  accessToken: String!
  accessTokenSecret: String!
  created: DateTime!
  refreshed: DateTime!
  databaseId: Int!
}

type Query {
  """The ID of the object"""
  node(id: ID!): Node
  viewer: ViewerType!
}

type QuoteType {
  volume: Int
  lastTrade: Decimal
  lastTradeDirection: Decimal
  marketCap: Decimal
  sharesOutstanding: Int
  primaryExchange: String
  companyName: String
}

enum SaveSettingsError {
  INVALID_REFRESH_RATE
  DEFAULT_BROKER_REQUIRED
  DEFAULT_PROVIDER_REQUIRED
}

input SaveSettingsInput {
  """Data refresh rate in milliseconds."""
  refreshRate: Int
  defaultBrokerId: ID
  defaultProviderId: ID
  defaultAccountId: ID
  clientMutationId: String
}

type SaveSettingsPayload {
  error: SaveSettingsError
  errorMessage: String
  settings: SettingsNode
  clientMutationId: String
}

enum SellStockError {
  ACCOUNT_NOT_PROVIDED
}

input SellStockInput {
  providerId: ID!
  symbol: String!
  accountId: ID
  clientMutationId: String
}

type SellStockPayload {
  error: SellStockError
  errorMessage: String
  clientMutationId: String
}

type ServiceProviderConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!
  edges: [ServiceProviderEdge!]!
}

type ServiceProviderEdge {
  cursor: String!
  node: ServiceProviderNode!
}

type ServiceProviderNode implements Node & DatabaseId {
  """The ID of the object."""
  id: ID!
  name: String!
  slug: String!
  protocol: ServiceProviderProtocol!
  consumerKey: String!
  consumerSecret: String!
  requestTokenUrl: String!
  authorizeUrl: String!
  accessTokenUrl: String!
  refreshUrl: String!
  revokeUrl: String!
  baseUrl: String!
  callbackConfigured: Boolean!
  accountKey: String!
  broker: BrokerNode!
  accounts(before: String, after: String, first: Int, last: Int): AccountNodeConnection!
  session: ProviderSessionNode
  databaseId: Int!
  quote(symbol: String): QuoteType
  sessionStatus: SessionStatus!
}

"""An enumeration."""
enum ServiceProviderProtocol {
  """OAuth 1.0a"""
  OAUTH1

  """OAuth 2"""
  OAUTH2
}

input ServiceProviderSlugInput {
  brokerSlug: String!
  priverderSlug: String!
}

enum SessionStatus {
  REQUESTING
  CONNECTED
  INACTIVE
  EXPIRED
  CLOSED
}

type SettingsNode implements Node & DatabaseId {
  """The ID of the object."""
  id: ID!
  refreshRate: Int!
  defaultBroker: BrokerNode
  defaultStrategy: TradingStrategyNode
  databaseId: Int!
}

input SyncAccountsInput {
  providerId: ID!
  clientMutationId: String
}

type SyncAccountsPayload {
  broker: BrokerNode
  error: AuthorizeConnectionError
  errorMessage: String
  clientMutationId: String
}

type TradingStrategyNode implements Node & DatabaseId {
  """The ID of the object."""
  id: ID!
  name: String!
  exposurePercent: Float!
  profitPercent: Float!
  lossPercent: Float!
  feePerTrade: Float!
  priceMargin: Float!
  databaseId: Int!
}

type ViewerCredentialsType {
  databaseId: Int!
  fullName: String!
}

type ViewerType {
  credentials: ViewerCredentialsType!
  settings: SettingsNode
  tradingStrategies: [TradingStrategyNode!]!
  brokers: [BrokerNode!]!
  broker(databaseId: ID, slug: String): BrokerNode
  serviceProviders: [ServiceProviderNode!]!
  serviceProvider(databaseId: ID, slug: ServiceProviderSlugInput): ServiceProviderNode
  accounts: [AccountNode!]!
  orders(providerId: ID!, accountId: ID): [OrderType!]!
  positions(providerId: ID!, accountId: ID): [PositionType!]!
}
